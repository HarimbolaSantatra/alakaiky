#!/usr/bin/env python

import subprocess
import argparse
import yaml
import logging

with open('config.yaml', 'r') as conf_file:
    conf = yaml.safe_load(conf_file)
    USERNAME = conf["username"]
    IP = conf["ip"]
    REMOTE_HOME = conf["remote_home"]

REMOTE_REF = "{}@{}".format(USERNAME, IP)
DEST_DIR = "./alk-dest/"


def exec_on_remote(
        cmds: list, 
        dry_run=False,
        debug=False,
        is_root=True
        ):
    """execute a sets of command on a remote host"""
    if debug:
        logging.basicConfig(level=logging.DEBUG)
    logging.debug("Beginning execution on remote ...")
    remote_cmd = ""
    iteration = 0
    nb_cmd = len(cmds)
    for cmd in cmds:
        logging.debug(f"cmd: {cmd}")
        if is_root:
            remote_cmd += "sudo "
        remote_cmd += cmd + " "
        logging.debug(f"result: {remote_cmd}")
        iteration += 1
        logging.debug(f"iteration: {iteration}")
        if iteration != nb_cmd:
            remote_cmd += " && "
    remote_cmd = "ssh -t {0} \"{1}\"".format(
            REMOTE_REF,
            remote_cmd
            )

    if dry_run:
        print("\n========")
        print("Command to run on remote:\n\t{}".format(remote_cmd))
        print("========\n")
    else:
        logging.info("Command: {}".format(remote_cmd))
        logging.info("Executing subprocess ...")
        subprocess.run(remote_cmd, shell=True, check=False)


def push(local_files: list, dests: list, dry_run=False, debug=False, is_root=True):
    """
    Sync local file to remote destination.
    files: local files
    dests: destination folders
    """

    if debug:
        logging.basicConfig(level=logging.DEBUG)

    files: str = " ".join(local_files)

    logging.info("Remote files to copy: {}".format(files))

    # sync to REMOTE_HOME first
    logging.debug("Copying from local to {}:{}".format(
        REMOTE_REF, REMOTE_HOME))
    rsync_cmd = "rsync -aP {0} {1}".format(
            files,
            "{}:{}".format(REMOTE_REF, REMOTE_HOME)
            )
    subprocess.run(rsync_cmd, shell=True, check=True)

    # ... then sync to remote root folder: dest
    rsync_cmd = ""
    for i in range(len(dests)):
        rsync_cmd += "rsync -aP {0} {1}".format(
                "{}/{}".format(REMOTE_HOME, local_files[i]),
                dests[i]
                )
        if i != (len(dests) - 1):
            rsync_cmd += " && "

    logging.debug("Command to execute on remote server: {}".format(rsync_cmd))
    logging.debug("dry_run: " + str(dry_run))
    logging.debug("is_root: " + str(is_root))

    exec_on_remote(
            [rsync_cmd],
            dry_run=dry_run,
            debug=debug,
            is_root=is_root,
            )



def pull(
        remote_files: list,
        dry_run=False,
        debug=False,
        is_root=True
        ):
    """ 
    Retrieve files on remote server and put it into the DEST_DIR directory
    remote_files: a list of full files path
    """
    # sync to root folder -> REMOTE_HOME first

    if debug:
        logging.basicConfig(level=logging.DEBUG)
    logging.info("Remote file to copy: {}".format(
        ", ".join(remote_files)))

    rsync_cmd = ""
    for i in range(len(remote_files)):
        rsync_cmd += "rsync -aP {0} {1}".format(
            remote_files[i],
            REMOTE_HOME)
        if i != len(remote_files) - 1:
            rsync_cmd += " && "

    exec_on_remote([rsync_cmd],
                   dry_run=dry_run,
                   debug=debug,
                   is_root=is_root)

    # ... then sync to REMOTE_HOME -> local
    rsync_cmd = "rsync ".format(REMOTE_REF)
    for i in range(len(remote_files)):
        rsync_cmd += "{}:{} ".format(REMOTE_REF, remote_files[i])
    rsync_cmd += DEST_DIR
    logging.info(f"Copying to {DEST_DIR}")
    if dry_run:
        print("\n========")
        print("Remote files to copy: {}".format(
            ", ".join(remote_files)
            ))
        print("Command to run on copy from remote to local: {}".format(rsync_cmd))
        print("========\n")
    else:
        subprocess.run(rsync_cmd, shell=True, check=True)


def bad_test():
    root_location = "/var/ossec"
    # /var/ossec is not readable for non-root user
    cmds = [
            f"ls -lh {root_location}"
            ]
    exec_on_remote(cmds,
                   is_root=True)
    exec_on_remote(cmds,
                   is_root=False)


def map_log_level(level: str):
    """
    handle log level. Map a 'level' string to a log level
    """
    level = level.lower()
    if level == "debug":
        return logging.DEBUG
    elif level == "info":
        return logging.INFO
    elif level == "warning":
        return logging.WARNING
    elif level == "error":
        return logging.ERROR
    elif level == "critical":
        return logging.CRITICAL
    elif level == "debug":
        return logging.WARNING
    else:
        return logging.WARNING


def main():

    # Set parser
    parser = argparse.ArgumentParser(description="Copy files between remote and local environment")
    parser.add_argument("-n", "--dry-run",
                        dest="dry_run",
                        help=f"Do not execute. Instead, execute a dry-run",
                        action="store_true")
    parser.add_argument("-l", "--log",
                        default="warning",
                        dest="log_level",
                        metavar="LOG",
                        help=f"Set log level: CRITICAL | DEBUG | INFO | WARNING (default)")
    parser.add_argument("-o", "--no-root",
                        dest="is_root",
                        help="Execute remote command without sudo privileges. Default to false.",
                        action="store_false")
    args = parser.parse_args()

    log_level = map_log_level(args.log_level)
    logging.basicConfig(level=log_level)
    logging.debug("Configuration done.")
    logging.debug("REMOTE_HOME is " + REMOTE_HOME)
    logging.debug("IP is " + IP)
    logging.debug("USERNAME is " + USERNAME)

    test_files = ["/home/santatra/perso/alakaiky/test1", "/home/santatra/perso/alakaiky/test2"]

    pull(test_files,
         debug=args.log_level, 
         dry_run=args.dry_run,
         is_root=args.is_root)


if __name__ == '__main__':
    main()
